<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>S5 Camera (All-in-One)</title>
  <style>
    :root{
      --bg:#0b0c10;
      --panel:#10131a;
      --line:#1e2633;
      --text:#e9eefc;
      --muted:#9aa6c0;
      --accent:#7aa7ff;
      --btn:#1a2333;
    }
    *{box-sizing:border-box; font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;}
    body{margin:0; background:var(--bg); color:var(--text);}
    .top{
      display:flex; align-items:center; justify-content:space-between;
      padding:14px 14px 10px;
      border-bottom:1px solid rgba(255,255,255,.06);
    }
    .title{font-weight:800; letter-spacing:.3px;}
    .pill{
      border:1px solid rgba(255,255,255,.12);
      padding:8px 12px; border-radius:999px; color:var(--muted);
      background:rgba(255,255,255,.03);
      font-weight:700;
    }
    .wrap{max-width:900px; margin:0 auto; padding:12px;}
    .stage{
      background:linear-gradient(180deg, rgba(255,255,255,.04), rgba(255,255,255,.015));
      border:1px solid rgba(255,255,255,.07);
      border-radius:18px;
      overflow:hidden;
      position:relative;
    }
    #preview{
      width:100%;
      aspect-ratio:4/3;
      background:#000;
      object-fit:cover;
      display:block;
    }
    #overlay{
      position:absolute; inset:0;
      pointer-events:none;
      display:flex; align-items:flex-start; justify-content:center;
      padding:14px;
    }
    .hint{
      max-width:92%;
      background:rgba(0,0,0,.45);
      border:1px solid rgba(255,255,255,.12);
      color:var(--text);
      padding:10px 12px;
      border-radius:14px;
      font-size:14px;
      line-height:1.25;
      backdrop-filter: blur(6px);
      opacity:.95;
    }
    .centerGuide{
      position:absolute; left:50%; top:50%;
      transform:translate(-50%,-50%);
      background:rgba(0,0,0,.45);
      border:1px solid rgba(255,255,255,.12);
      padding:10px 14px;
      border-radius:16px;
      backdrop-filter: blur(6px);
      font-weight:800;
      display:none;
      gap:10px; align-items:center;
    }
    .centerGuide span{color:var(--accent);}
    .row{
      display:flex; gap:10px; flex-wrap:wrap;
      padding:12px 2px 2px;
      align-items:center; justify-content:space-between;
    }
    .controls{
      display:flex; gap:10px; flex-wrap:wrap; align-items:center;
    }
    button{
      background:var(--btn);
      color:var(--text);
      border:1px solid rgba(255,255,255,.12);
      border-radius:14px;
      padding:10px 12px;
      font-weight:800;
      cursor:pointer;
    }
    button:active{transform:scale(.99);}
    button.primary{border-color:rgba(122,167,255,.45); box-shadow:0 0 0 2px rgba(122,167,255,.12) inset;}
    button.danger{border-color:rgba(255,120,120,.35);}
    .modebar{
      display:flex; gap:10px;
      overflow:auto;
      padding:12px 2px 6px;
      -webkit-overflow-scrolling: touch;
    }
    .mode{
      flex:0 0 auto;
      padding:10px 14px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,.12);
      background:rgba(255,255,255,.03);
      color:var(--muted);
      font-weight:900;
      white-space:nowrap;
    }
    .mode.active{
      color:var(--text);
      border-color:rgba(122,167,255,.6);
      box-shadow:0 0 0 2px rgba(122,167,255,.12) inset;
    }
    .bottom{
      display:flex; align-items:center; justify-content:space-between;
      gap:10px;
      padding:10px 2px 18px;
    }
    .thumb{
      width:70px; height:70px; border-radius:14px;
      border:1px solid rgba(255,255,255,.12);
      background:#000;
      object-fit:cover;
    }
    .shutter{
      width:84px; height:84px; border-radius:999px;
      border:4px solid rgba(255,255,255,.18);
      background:rgba(255,255,255,.05);
      display:grid; place-items:center;
    }
    .shutter .inner{
      width:58px; height:58px; border-radius:999px;
      background:#fff;
    }
    .rightBtns{display:flex; gap:10px; align-items:center;}
    .small{font-size:12px; color:var(--muted); margin-top:4px}
    .panel{
      background:rgba(255,255,255,.03);
      border:1px solid rgba(255,255,255,.08);
      border-radius:16px;
      padding:10px 12px;
      margin-top:10px;
    }
    .panel h3{margin:0 0 6px; font-size:14px}
    .kv{display:flex; gap:10px; flex-wrap:wrap; font-size:13px; color:var(--muted)}
    .kv b{color:var(--text)}
    input[type="range"]{width:220px;}
    .hidden{display:none !important;}
    canvas{display:none;}
  </style>
</head>
<body>
  <div class="top">
    <div class="title">S5 카메라</div>
    <div class="pill" id="modePill">PHOTO</div>
  </div>

  <div class="wrap">
    <div class="stage">
      <video id="preview" autoplay muted playsinline></video>
      <div id="overlay"><div class="hint" id="hint">아래 “카메라 시작”을 눌러 미리보기를 켜세요.</div></div>

      <div class="centerGuide" id="wideGuide">
        <span id="arrow">←</span>
        <div>옆으로 천천히 움직이기 · <span id="wideCount">0</span>/<span id="wideMax">6</span></div>
        <span id="arrow2">→</span>
      </div>
    </div>

    <div class="row">
      <div class="controls">
        <button class="primary" id="btnStart">카메라 시작</button>
        <button id="btnFlip">전/후면</button>
        <button id="btnStop" class="danger">정지</button>
      </div>
      <div class="controls">
        <button id="btnSave">저장</button>
      </div>
    </div>
    <div class="small" id="status">상태: 대기중</div>

    <div class="modebar" id="modebar"></div>

    <div class="bottom">
      <img id="thumb" class="thumb" alt="thumbnail"/>
      <div class="shutter" id="btnShutter" title="셔터">
        <div class="inner"></div>
      </div>
      <div class="rightBtns">
        <button id="btnRec" class="primary">REC</button>
        <button id="btnClear">리셋</button>
      </div>
    </div>

    <div class="panel">
      <h3>현재 모드 설정</h3>
      <div class="kv" id="settingsKV"></div>
      <div class="kv" id="extraControls"></div>
    </div>
  </div>

  <canvas id="capCanvas"></canvas>
  <canvas id="workCanvas"></canvas>

<script>
(() => {
  // ====== 상태 ======
  const video = document.getElementById('preview');
  const hint = document.getElementById('hint');
  const statusEl = document.getElementById('status');
  const modePill = document.getElementById('modePill');
  const modebar = document.getElementById('modebar');
  const thumb = document.getElementById('thumb');

  const capCanvas = document.getElementById('capCanvas');
  const workCanvas = document.getElementById('workCanvas');
  const capCtx = capCanvas.getContext('2d', { willReadFrequently: true });
  const workCtx = workCanvas.getContext('2d', { willReadFrequently: true });

  const wideGuide = document.getElementById('wideGuide');
  const wideCountEl = document.getElementById('wideCount');
  const wideMaxEl = document.getElementById('wideMax');

  let stream = null;
  let currentFacing = 'user'; // 'user' or 'environment'
  let currentMode = 'photo';
  let lastBlobUrl = null;

  let mediaRecorder = null;
  let recordedChunks = [];

  // Wide selfie frames
  let wideFrames = []; // ImageData array
  let wideMax = 6;
  let wideOverlap = 0.28; // overlap ratio (feather)
  let wideDirection = 1; // 1 right, -1 left

  // Slow/Fast record playback factor (simple post-playback speed)
  // 실제로 촬영 자체 fps를 바꾸는 건 브라우저/기기 제한이 있어 "재생 속도"로 처리
  let playbackRate = 1.0;

  // ====== 모드 목록 ======
  const MODES = [
    { id:'photo', label:'사진', pill:'PHOTO' },
    { id:'video', label:'동영상', pill:'VIDEO' },
    { id:'panorama', label:'파노라마', pill:'PANO' },
    { id:'motionpano', label:'모션파노라마', pill:'M-PANO' },
    { id:'pro', label:'프로', pill:'PRO' },

    { id:'shotmore', label:'샷&모어', pill:'SHOT' },
    { id:'aqua', label:'아쿠아', pill:'AQUA' },
    { id:'outfocus', label:'아웃포커스', pill:'BOKEH' },
    { id:'wideselfie', label:'와이드셀프샷', pill:'WIDE' },
    { id:'rearcamsel', label:'리어캠 셀피', pill:'REAR' },

    { id:'slow', label:'슬로우(0.5x)', pill:'SLOW' },
    { id:'fast', label:'패스트(4x)', pill:'FAST' },
  ];

  // ====== UI 만들기 ======
  function buildModebar(){
    modebar.innerHTML = '';
    MODES.forEach(m=>{
      const b = document.createElement('button');
      b.className = 'mode' + (m.id===currentMode ? ' active':'');
      b.textContent = m.label;
      b.onclick = ()=> setMode(m.id);
      modebar.appendChild(b);
    });
  }

  function setMode(id){
    currentMode = id;
    buildModebar();
    const m = MODES.find(x=>x.id===id);
    modePill.textContent = m ? m.pill : 'MODE';
    setHintForMode();
    renderSettings();

    // wide selfie guide
    if(id==='wideselfie'){
      wideGuide.style.display = 'flex';
      wideCountEl.textContent = String(wideFrames.length);
      wideMaxEl.textContent = String(wideMax);
    } else {
      wideGuide.style.display = 'none';
    }

    // rear cam selfie -> force environment cam if possible
    if(id==='rearcamsel'){
      currentFacing = 'environment';
      if(stream) startCamera(true);
    }

    // slow/fast are video recording variants
    if(id==='slow'){ playbackRate = 0.5; }
    else if(id==='fast'){ playbackRate = 4.0; }
    else { playbackRate = 1.0; }
  }

  function setHintForMode(){
    const map = {
      photo:'셔터로 사진 촬영',
      video:'REC로 녹화 시작/정지',
      panorama:'연속 촬영으로 가로로 이어붙이기(간단 버전)',
      motionpano:'여러 장 찍어 흔들림/움직임 느낌(간단 버전)',
      pro:'노출/밝기 같은 수동 느낌(간단 버전)',
      shotmore:'셔터를 여러 번 → “저장”에서 1장으로 합치기',
      aqua:'물속 느낌 필터(색감 보정)',
      outfocus:'중앙은 선명, 바깥은 블러(간단 아웃포커스)',
      wideselfie:'셔터를 여러 번 누르며 좌우로 움직이기 → “저장”',
      rearcamsel:'후면 카메라로 셀피처럼(거울모드 옵션)',
      slow:'동영상 녹화 후 0.5x로 재생(간단 슬로우)',
      fast:'동영상 녹화 후 4x로 재생(간단 패스트)'
    };
    hint.textContent = map[currentMode] || '모드 선택';
  }

  function renderSettings(){
    const kv = document.getElementById('settingsKV');
    const extra = document.getElementById('extraControls');
    kv.innerHTML = '';
    extra.innerHTML = '';

    const addKV = (k,v)=> {
      const span = document.createElement('span');
      span.innerHTML = `<b>${k}</b>: ${v}`;
      kv.appendChild(span);
    };

    addKV('카메라', currentFacing==='user'?'전면':'후면');
    addKV('미리보기', stream?'ON':'OFF');
    addKV('모드', MODES.find(m=>m.id===currentMode)?.label || currentMode);

    if(currentMode==='wideselfie'){
      // overlap slider
      const wrap = document.createElement('span');
      wrap.innerHTML = `겹침 <input id="overlap" type="range" min="0.15" max="0.45" step="0.01" value="${wideOverlap}"> <b id="ovv">${Math.round(wideOverlap*100)}%</b>`;
      extra.appendChild(wrap);
      setTimeout(()=>{
        const r = document.getElementById('overlap');
        const ovv = document.getElementById('ovv');
        r.oninput = ()=>{
          wideOverlap = parseFloat(r.value);
          ovv.textContent = `${Math.round(wideOverlap*100)}%`;
        };
      },0);

      const wrap2 = document.createElement('span');
      wrap2.innerHTML = `최대 프레임 <input id="wmax" type="range" min="2" max="10" step="1" value="${wideMax}"> <b id="wmv">${wideMax}</b>`;
      extra.appendChild(wrap2);
      setTimeout(()=>{
        const r = document.getElementById('wmax');
        const wmv = document.getElementById('wmv');
        r.oninput = ()=>{
          wideMax = parseInt(r.value,10);
          wmv.textContent = String(wideMax);
          wideMaxEl.textContent = String(wideMax);
        };
      },0);

      const wrap3 = document.createElement('span');
      const btnDir = document.createElement('button');
      btnDir.textContent = (wideDirection===1) ? '방향: 오른쪽→' : '방향: ←왼쪽';
      btnDir.onclick = ()=>{
        wideDirection *= -1;
        btnDir.textContent = (wideDirection===1) ? '방향: 오른쪽→' : '방향: ←왼쪽';
        document.getElementById('arrow').textContent = wideDirection===1?'←':'→';
        document.getElementById('arrow2').textContent = wideDirection===1?'→':'←';
      };
      wrap3.appendChild(btnDir);
      extra.appendChild(wrap3);
    }

    if(currentMode==='outfocus'){
      const wrap = document.createElement('span');
      wrap.innerHTML = `블러 강도 <input id="blur" type="range" min="4" max="20" step="1" value="10"> <b id="blv">10</b>`;
      extra.appendChild(wrap);
      setTimeout(()=>{
        const r=document.getElementById('blur');
        const blv=document.getElementById('blv');
        r.oninput=()=> blv.textContent = r.value;
      },0);
    }
  }

  // ====== 카메라 시작/정지 (미리보기 핵심) ======
  async function startCamera(restart=false){
    try{
      if(stream){
        stream.getTracks().forEach(t=>t.stop());
        stream=null;
      }

      const constraints = {
        audio: false,
        video: {
          facingMode: { ideal: currentFacing },
          width: { ideal: 1280 },
          height:{ ideal: 960 }
        }
      };

      status('카메라 요청중…');
      stream = await navigator.mediaDevices.getUserMedia(constraints);

      video.srcObject = stream;

      // 일부 폰: 메타데이터 로드 후 play 해야 함
      await new Promise(res=>{
        if(video.readyState >= 1) return res();
        video.onloadedmetadata = () => res();
      });

      // 사용자 제스처 안에서 호출하면 성공률↑
      await video.play();

      status('미리보기 ON ✅');
      hint.textContent = '미리보기 켜짐! ' + (hint.textContent || '');
      renderSettings();
    } catch(e){
      console.error(e);
      status('카메라 실패 ❌ (권한/HTTPS 확인)');
      hint.textContent = '카메라가 안 되면: HTTPS + 카메라 권한 허용 + 새로고침';
    }
  }

  function stopCamera(){
    if(stream){
      stream.getTracks().forEach(t=>t.stop());
      stream=null;
    }
    video.srcObject = null;
    status('미리보기 OFF');
    renderSettings();
  }

  // ====== 캡처 유틸 ======
  function grabFrameToCanvas(){
    const w = video.videoWidth || 1280;
    const h = video.videoHeight || 960;
    capCanvas.width = w;
    capCanvas.height = h;
    capCtx.drawImage(video, 0, 0, w, h);
    return { w, h };
  }

  function canvasToBlob(canvas, type='image/jpeg', quality=0.92){
    return new Promise(res => canvas.toBlob(res, type, quality));
  }

  function downloadBlob(blob, filename){
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    a.remove();
    setTimeout(()=> URL.revokeObjectURL(url), 1500);
  }

  function setThumbFromBlob(blob){
    if(lastBlobUrl) URL.revokeObjectURL(lastBlobUrl);
    lastBlobUrl = URL.createObjectURL(blob);
    thumb.src = lastBlobUrl;
  }

  // ====== 모드별 처리 ======
  async function doPhotoCapture(){
    if(!stream) return status('카메라부터 시작!');

    const {w,h} = grabFrameToCanvas();

    // 기본: 캔버스 그대로
    workCanvas.width = w; workCanvas.height = h;
    workCtx.clearRect(0,0,w,h);
    workCtx.drawImage(capCanvas,0,0);

    // 모드별 필터
    if(currentMode==='aqua'){
      applyAqua(workCtx, w, h);
    } else if(currentMode==='outfocus'){
      applyOutfocus(workCtx, w, h);
    } else if(currentMode==='shotmore'){
      // 샷&모어: 프레임 누적 (나중에 저장에서 합치기)
      wideFrames.push(workCtx.getImageData(0,0,w,h));
      status(`샷&모어 프레임 ${wideFrames.length}장`);
      hint.textContent = `셔터를 더 누르거나, “저장”을 눌러 1장으로 합치세요. (${wideFrames.length}장)`;
      return;
    } else if(currentMode==='wideselfie'){
      // 와이드셀프샷: 프레임 누적 (나중에 저장에서 이어붙이기)
      wideFrames.push(workCtx.getImageData(0,0,w,h));
      wideCountEl.textContent = String(wideFrames.length);
      status(`와이드 프레임 ${wideFrames.length}/${wideMax}`);
      hint.textContent = `셔터를 여러 번 누르며 ${wideDirection===1?'오른쪽':'왼쪽'}으로 천천히 이동! (${wideFrames.length}/${wideMax})`;

      if(wideFrames.length >= wideMax){
        status('최대 프레임 도달! 저장을 누르세요.');
      }
      return;
    } else if(currentMode==='panorama' || currentMode==='motionpano'){
      // 간단 버전: 파노라마도 wideFrames로 처리 (저장에서 이어붙이기)
      wideFrames.push(workCtx.getImageData(0,0,w,h));
      status(`${currentMode==='panorama'?'파노라마':'모션파노라마'} 프레임 ${wideFrames.length}장`);
      hint.textContent = `셔터를 여러 번 누르고 “저장”을 눌러 합치세요. (${wideFrames.length}장)`;
      return;
    }

    const blob = await canvasToBlob(workCanvas);
    setThumbFromBlob(blob);
    downloadBlob(blob, `s5_${currentMode}_${Date.now()}.jpg`);
    status('사진 저장 완료 ✅');
  }

  function applyAqua(ctx, w, h){
    // 간단 아쿠아: 푸른색 증가 + 대비 약간
    const img = ctx.getImageData(0,0,w,h);
    const d = img.data;
    for(let i=0;i<d.length;i+=4){
      let r=d[i], g=d[i+1], b=d[i+2];
      // aqua tone
      b = Math.min(255, b*1.20 + 18);
      g = Math.min(255, g*1.08 + 6);
      r = Math.max(0, r*0.92 - 4);
      // contrast-ish
      d[i]   = clamp((r-128)*1.05 + 128);
      d[i+1] = clamp((g-128)*1.05 + 128);
      d[i+2] = clamp((b-128)*1.05 + 128);
    }
    ctx.putImageData(img,0,0);
  }

  function applyOutfocus(ctx, w, h){
    // "진짜 인물 분리"는 웹에서 어렵기 때문에
    // 중앙은 선명, 바깥은 블러(가짜 아웃포커스) 방식으로 구현
    const blurRange = parseInt(document.getElementById('blur')?.value || '10',10);

    // 원본 백업
    const original = ctx.getImageData(0,0,w,h);

    // 전체를 블러처럼 만들기: canvas filter 이용 (지원되는 폰 많음)
    workCtx.clearRect(0,0,w,h);
    workCtx.filter = `blur(${blurRange}px)`;
    workCtx.drawImage(capCanvas,0,0,w,h);
    workCtx.filter = 'none';

    // 중앙 원형 마스크만 원본을 덮어씌워 선명 유지
    const cx=w/2, cy=h/2;
    const radius = Math.min(w,h)*0.28;
    const feather = radius*0.55;

    // 마스크 영역만 원본 draw
    const temp = document.createElement('canvas');
    temp.width=w; temp.height=h;
    const tctx = temp.getContext('2d');
    tctx.putImageData(original,0,0);

    // 마스크로 덮기
    workCtx.save();
    const grad = workCtx.createRadialGradient(cx, cy, radius, cx, cy, radius+feather);
    grad.addColorStop(0, 'rgba(255,255,255,1)');
    grad.addColorStop(1, 'rgba(255,255,255,0)');
    workCtx.globalCompositeOperation = 'source-over';

    // 마스크를 알파로 쓰기
    const mask = document.createElement('canvas');
    mask.width=w; mask.height=h;
    const mctx = mask.getContext('2d');
    mctx.fillStyle='black';
    mctx.fillRect(0,0,w,h);
    mctx.fillStyle=grad;
    mctx.beginPath();
    mctx.arc(cx,cy,radius+feather,0,Math.PI*2);
    mctx.closePath();
    mctx.fill();

    // 원본을 마스크로 클립
    const masked = document.createElement('canvas');
    masked.width=w; masked.height=h;
    const x = masked.getContext('2d');
    x.drawImage(temp,0,0);
    x.globalCompositeOperation='destination-in';
    x.drawImage(mask,0,0);

    // 블러 위에 선명 중앙 합성
    workCtx.drawImage(masked,0,0);
    workCtx.restore();
  }

  function clamp(v){ return Math.max(0, Math.min(255, v|0)); }

  // ====== 프레임 합치기(저장) ======
  async function saveCombined(){
    if(wideFrames.length===0){
      status('합칠 프레임이 없음');
      return;
    }
    // shotmore: 그냥 평균 합성 (간단)
    if(currentMode==='shotmore'){
      const img0 = wideFrames[0];
      const w=img0.width, h=img0.height;
      workCanvas.width=w; workCanvas.height=h;
      const out = workCtx.createImageData(w,h);
      const n = wideFrames.length;
      for(let i=0;i<out.data.length;i+=4){
        let r=0,g=0,b=0,a=0;
        for(const fr of wideFrames){
          r += fr.data[i];
          g += fr.data[i+1];
          b += fr.data[i+2];
          a += fr.data[i+3];
        }
        out.data[i]   = (r/n)|0;
        out.data[i+1] = (g/n)|0;
        out.data[i+2] = (b/n)|0;
        out.data[i+3] = (a/n)|0;
      }
      workCtx.putImageData(out,0,0);
      const blob = await canvasToBlob(workCanvas);
      setThumbFromBlob(blob);
      downloadBlob(blob, `s5_shotmore_${Date.now()}.jpg`);
      status('샷&모어 합치기 완료 ✅');
      return;
    }

    // wide/pano/motionpano: 이어붙이기 + 겹치기 블렌딩(간단 feather)
    const base = wideFrames[0];
    const fw = base.width, fh = base.height;

    const overlapPx = Math.floor(fw * wideOverlap);
    const step = fw - overlapPx;

    const count = wideFrames.length;
    const totalW = fw + step*(count-1);

    workCanvas.width = totalW;
    workCanvas.height = fh;

    // 배경
    workCtx.clearRect(0,0,totalW,fh);
    workCtx.fillStyle = '#000';
    workCtx.fillRect(0,0,totalW,fh);

    // 각 프레임 그리기(겹치는 부분 feather)
    for(let k=0;k<count;k++){
      const x = (wideDirection===1) ? (k*step) : ((count-1-k)*step);

      // frame -> temp canvas
      const tmp = document.createElement('canvas');
      tmp.width=fw; tmp.height=fh;
      const t = tmp.getContext('2d');
      t.putImageData(wideFrames[k],0,0);

      // feather 마스크 만들기
      const mask = document.createElement('canvas');
      mask.width=fw; mask.height=fh;
      const m = mask.getContext('2d');

      // 기본은 불투명
      m.clearRect(0,0,fw,fh);

      // 왼쪽/오른쪽 겹침을 부드럽게
      // k==0이면 전체 1, k>0이면 왼쪽 overlap 구간만 서서히 0->1
      const g = m.createLinearGradient(0,0,fw,0);
      if(k===0){
        g.addColorStop(0,'rgba(255,255,255,1)');
        g.addColorStop(1,'rgba(255,255,255,1)');
      } else {
        // 왼쪽 overlap: 0 -> 1
        const p = overlapPx/fw;
        g.addColorStop(0,'rgba(255,255,255,0)');
        g.addColorStop(Math.max(0, p*0.85), 'rgba(255,255,255,0)');
        g.addColorStop(Math.min(1, p), 'rgba(255,255,255,1)');
        g.addColorStop(1,'rgba(255,255,255,1)');
      }
      m.fillStyle = g;
      m.fillRect(0,0,fw,fh);

      // tmp에 마스크 적용
      const masked = document.createElement('canvas');
      masked.width=fw; masked.height=fh;
      const mx = masked.getContext('2d');
      mx.drawImage(tmp,0,0);
      mx.globalCompositeOperation = 'destination-in';
      mx.drawImage(mask,0,0);

      workCtx.drawImage(masked, x, 0);
    }

    const blob = await canvasToBlob(workCanvas, 'image/jpeg', 0.9);
    setThumbFromBlob(blob);
    downloadBlob(blob, `s5_${currentMode}_${Date.now()}.jpg`);
    status('이어붙이기 저장 완료 ✅');
  }

  // ====== 동영상 녹화 ======
  async function toggleRecord(){
    if(!stream) return status('카메라부터 시작!');
    if(mediaRecorder && mediaRecorder.state === 'recording'){
      mediaRecorder.stop();
      return;
    }

    recordedChunks = [];
    try{
      // mimeType은 폰마다 다름 → 가능한 것부터
      const options = pickRecorderOptions();
      mediaRecorder = new MediaRecorder(stream, options);
    }catch(e){
      console.error(e);
      status('녹화 불가(브라우저 제한)');
      return;
    }

    mediaRecorder.ondataavailable = (e)=> {
      if(e.data && e.data.size>0) recordedChunks.push(e.data);
    };
    mediaRecorder.onstop = async ()=>{
      const blob = new Blob(recordedChunks, { type: recordedChunks[0]?.type || 'video/webm' });

      // 다운로드
      downloadBlob(blob, `s5_${currentMode}_video_${Date.now()}.webm`);
      status('동영상 저장 완료 ✅');

      // 슬로/패스트는 “재생속도 안내”만 (파일 자체 변환은 웹에서 어려움)
      if(currentMode==='slow' || currentMode==='fast'){
        hint.textContent = `저장된 영상은 기본 속도예요. 재생 앱에서 ${playbackRate}x로 재생해보세요!`;
      }

      // 썸네일은 그대로(영상 썸네일 추출은 생략)
    };

    mediaRecorder.start();
    status('녹화중… ⏺️');
  }

  function pickRecorderOptions(){
    const candidates = [
      { mimeType:'video/webm;codecs=vp9' },
      { mimeType:'video/webm;codecs=vp8' },
      { mimeType:'video/webm' },
      { mimeType:'video/mp4' }, // 대부분 안 될 수 있음
      {}
    ];
    for(const opt of candidates){
      try{
        if(!opt.mimeType) return opt;
        if(MediaRecorder.isTypeSupported(opt.mimeType)) return opt;
      }catch(_){}
    }
    return {};
  }

  // ====== 버튼 연결 ======
  document.getElementById('btnStart').onclick = async ()=>{
    // 사용자 터치 안에서 play까지 실행 → 미리보기 성공률 크게 증가
    await startCamera();
  };
  document.getElementById('btnStop').onclick = ()=> stopCamera();
  document.getElementById('btnFlip').onclick = async ()=>{
    currentFacing = (currentFacing==='user') ? 'environment' : 'user';
    if(stream) await startCamera(true);
    renderSettings();
  };
  document.getElementById('btnShutter').onclick = ()=> doPhotoCapture();
  document.getElementById('btnSave').onclick = ()=> saveCombined();
  document.getElementById('btnClear').onclick = ()=>{
    wideFrames = [];
    wideCountEl.textContent = '0';
    status('프레임 리셋 완료');
    setHintForMode();
  };
  document.getElementById('btnRec').onclick = ()=> toggleRecord();

  function status(t){
    statusEl.textContent = '상태: ' + t;
  }

  // ====== 초기 ======
  buildModebar();
  setMode('photo');
  renderSettings();

  // 권한/HTTPS 안내
  hint.textContent = '미리보기는 “카메라 시작”을 눌러야 켜져요(자동재생 차단 때문에).';

})();
</script>
</body>
</html>